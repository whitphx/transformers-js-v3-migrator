from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import logging


class MigrationType(Enum):
    README_SAMPLES = "readme_samples"
    MODEL_BINARIES = "model_binaries"
    CONFIG_FILES = "config_files"
    EXAMPLE_SCRIPTS = "example_scripts"


class MigrationStatus(Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"
    NOT_APPLICABLE = "not_applicable"
    DRY_RUN = "dry_run"
    LOCAL = "local"


@dataclass
class MigrationResult:
    migration_type: MigrationType
    status: MigrationStatus
    changes_made: bool
    error_message: Optional[str] = None
    pr_url: Optional[str] = None
    files_modified: List[str] = None
    
    def __post_init__(self):
        if self.files_modified is None:
            self.files_modified = []


class BaseMigration(ABC):
    """Base class for all migration types"""
    
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @property
    @abstractmethod
    def migration_type(self) -> MigrationType:
        """Return the migration type this class handles"""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """Return a human-readable description of what this migration does"""
        pass
    
    @abstractmethod
    def is_applicable(self, repo_path: str, repo_id: str) -> bool:
        """Check if this migration is applicable to the repository"""
        pass
    
    @abstractmethod
    def apply_migration(self, repo_path: str, repo_id: str, interactive: bool = True) -> MigrationResult:
        """Apply the migration and return the result"""
        pass
    
    def get_branch_name(self) -> str:
        """Get the branch name for this migration type"""
        return f"transformersjs-v3-{self.migration_type.value}"
    
    def get_pr_title(self) -> str:
        """Get the PR title for this migration type"""
        type_titles = {
            MigrationType.README_SAMPLES: "📝 Update README.md samples for Transformers.js v3",
            MigrationType.MODEL_BINARIES: "🔧 Convert model binaries for Transformers.js v3",
            MigrationType.CONFIG_FILES: "⚙️ Update config files for Transformers.js v3",
            MigrationType.EXAMPLE_SCRIPTS: "📚 Update example scripts for Transformers.js v3"
        }
        return type_titles.get(self.migration_type, f"🚀 {self.description}")
    
    def get_pr_description(self) -> str:
        """Get the PR description for this migration type"""
        return f"""This automated migration updates the model repository for Transformers.js v3.

## Changes Made:
- {self.description}

## Notes:
This is an automated migration focused on {self.migration_type.value.replace('_', ' ')}. 
Please review the changes before merging.

Generated by transformers-js-v3-migrator"""


class MigrationRegistry:
    """Registry for all available migration types"""
    
    def __init__(self):
        self._migrations: Dict[MigrationType, BaseMigration] = {}
        self.logger = logging.getLogger(__name__)
    
    def register(self, migration: BaseMigration):
        """Register a migration type"""
        self._migrations[migration.migration_type] = migration
        self.logger.info(f"Registered migration: {migration.migration_type.value}")
    
    def get_migration(self, migration_type: MigrationType) -> Optional[BaseMigration]:
        """Get a specific migration by type"""
        return self._migrations.get(migration_type)
    
    def get_all_migrations(self) -> List[BaseMigration]:
        """Get all registered migrations"""
        return list(self._migrations.values())
    
    def get_applicable_migrations(self, repo_path: str, repo_id: str, verbose: bool = False) -> List[BaseMigration]:
        """Get all migrations applicable to a repository with verbose mode"""
        applicable = []
        for migration_class in self._migrations.values():
            try:
                # Create a new instance with verbose mode for this session
                migration = migration_class.__class__(verbose=verbose)
                if migration.is_applicable(repo_path, repo_id):
                    applicable.append(migration)
                    self.logger.debug(f"Migration {migration.migration_type.value} is applicable to {repo_id}")
                else:
                    self.logger.debug(f"Migration {migration.migration_type.value} is not applicable to {repo_id}")
            except Exception as e:
                if verbose:
                    import traceback
                    self.logger.error(f"Error checking applicability of {migration_class.migration_type.value} for {repo_id}: {e}")
                    self.logger.debug(f"Full traceback:\n{traceback.format_exc()}")
                else:
                    self.logger.error(f"Error checking applicability of {migration_class.migration_type.value} for {repo_id}: {e}")
        
        return applicable


# Global registry instance
migration_registry = MigrationRegistry()